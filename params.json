{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Pheme","tagline":"Web interface for the Java Pregel implementation, Jpregel","google":"","body":"# Pheme: jPregel's Voice\r\n\r\n### Karl Lopker\r\n\r\nUCSB CMPSC 290B\r\n\r\n\r\n\r\n*Fall 2012*\r\n\r\n\r\n\r\n## Abstract\r\n\r\n\r\n\r\njPregel is a Java based implementation of Google's Pregel system[1] for distributed graph computation. The Pregel paper describes a web front end that comes with it. Currently jPregel does not come with such a front end. The goal of this project is to correct this and bring jPregel's functionality closer to Google's Pregel.\r\n\r\n\r\n\r\n## Introduction\r\n\r\n\r\n\r\nPheme is a web-based (HTTP) front end interface for jPregel. Pheme, who's name comes from the Greek goddess of gossip, is designed to facilitate bidirectional communication between jPregel and its users. jPregel will communicate with the user through logging mechanisms. The user will communicate to jPregel through system control widgets. Pheme is designed to be expandable, each jPregel component will register with the Pheme API and the component's controls will be rendered to the user dynamically. Adding another control page will not require a change in Pheme's source.\r\n\r\n\r\n\r\n## Functional Requirements\r\n\r\n\r\n\r\n- Display logs to user with level (DEBUG, WARN, INFO) filters\r\n\r\n- Widgets to control jPregel behavior\r\n\r\n  - ex. User can bring up or take down jPregel components with buttons\r\n\r\n\r\n\r\n## Performance Requirements\r\n\r\n\r\n\r\n- User actions must either be relatively instantaneous or asynchronous as to not freeze Pheme's interface.\r\n\r\n- jPregle to Pheme communication should only add negligible (< 0.1%) overhead to the system in both processing time and memory usage.\r\n\r\n\r\n\r\n## Key Technical Issues\r\n\r\n\r\n\r\n- Designing Pheme's jPregel side API. Essentially a callback-based remote logging system.\r\n\r\n- Generating front end widgets dynamically based on jPregel component abilities.\r\n\r\n- Giving the user at least the impression of real-time communication. Probably through WebSockets.\r\n\r\n- Configuring deployment in conjunction with jPregel.\r\n\r\n\r\n\r\n## Architecture\r\n\r\n\r\n\r\n- Pluggable Architecture\r\n\r\n  - Adding mew jPregel components should not change Pheme's source.\r\n\r\n- Non-blocking\r\n\r\n  - Communication/logging from jPregel should be non-blocking and handled in a different thread.\r\n\r\n- Location agnostic\r\n\r\n  - Pheme should communicate over TCP so it can be run anywhere in the jPregel system.\r\n\r\n\r\n\r\n## Experiments\r\n\r\n\r\n\r\n- Test jPregel runtimes and memory with and without the Pheme communication overhead.\r\n\r\n- Test Pheme scalability by registering a large amount of components and sending a lot of logging data.\r\n\r\n\r\n\r\n## Future Work\r\n\r\n- Support multiple users\r\n\r\n- Log in system with HTTPS\r\n\r\n- Generalize to other distributed systems\r\n\r\n\r\n\r\n## Conclusions\r\n\r\n\r\n\r\n## References\r\n\r\n\r\n\r\n[1] Grzegorz Malewicz, Matthew H. Austern, Aart J.C Bik, James C. Dehnert, Ilan Horn, Naty Leiser, and Grzegorz Czajkowski. 2010. Pregel: a system for large-scale graph processing. *In Proceedings of the 2010 ACM SIGMOD International Conference on Management of data* (SIGMOD '10). ACM, New York, NY, USA, 135-146. DOI=10.1145/1807167.1807184 http://doi.acm.org/10.1145/1807167.1807184\r\n"}